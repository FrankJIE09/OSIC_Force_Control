\documentclass[UTF8,12pt]{ctexart}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{longtable}
\geometry{a4paper, margin=2.5cm}

% 代码样式设置
\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{gray!10},
    frame=single,
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4,
    showspaces=false,
    showstringspaces=false
}

\title{混合力位控制实现文档\\基于约束的机器人表面力控仿真}
\author{基于 osic\_viewer\_Frank.py}
\date{}

\begin{document}

\maketitle

\tableofcontents
\newpage

\section{概述}

本文档详细解释 \texttt{osic\_viewer\_Frank.py} 代码的实现，该代码实现了基于约束的混合运动-力控制算法，用于 Franka Panda 机械臂在表面上的力控操作。

\subsection{主要特性}

\begin{itemize}
    \item \textbf{混合力位控制}：同时实现位置控制和力控制
    \item \textbf{约束处理}：使用 Pfaffian 约束描述表面接触
    \item \textbf{投影矩阵}：分离运动子空间和力子空间
    \item \textbf{动力学补偿}：使用任务空间质量矩阵和科里奥利项
    \item \textbf{实时可视化}：MuJoCo 3D 仿真显示
\end{itemize}

\section{理论基础}

\subsection{混合运动-力控制框架}

代码实现了基于公式 11.57--11.64 的混合运动-力控制框架：

\subsubsection{Pfaffian 约束（公式 11.57）}

对于刚性表面接触，约束方程为：
\begin{equation}
A(\theta) V = 0
\end{equation}

其中：
\begin{itemize}
    \item $A(\theta) \in \mathbb{R}^{k \times 6}$：约束矩阵
    \item $V \in \mathbb{R}^6$：任务空间速度（twist）
    \item $k$：约束数量（对于表面接触，$k=1$，约束法向运动）
\end{itemize}

\subsubsection{约束任务空间动力学（公式 11.59）}

\begin{equation}
F = \Lambda(\theta)\dot{V} + \eta(\theta, V) + A^T(\theta)\lambda
\end{equation}

其中：
\begin{itemize}
    \item $\Lambda(\theta)$：任务空间质量矩阵
    \item $\eta(\theta, V)$：任务空间科里奥利和重力项
    \item $\lambda$：拉格朗日乘数（约束力）
\end{itemize}

\subsubsection{投影矩阵（公式 11.63）}

投影矩阵将控制空间分解为运动子空间和力子空间：
\begin{equation}
P = I - A^T(A\Lambda^{-1}A^T)^{-1}A\Lambda^{-1}
\end{equation}

性质：
\begin{itemize}
    \item $P$ 投影到运动子空间（维度：$6-k$）
    \item $I-P$ 投影到力子空间（维度：$k$）
    \item $P \cdot (I-P) = 0$（正交补）
\end{itemize}

\subsubsection{混合控制器（公式 11.64）}

控制律为：
\begin{equation}
\begin{split}
\tau &= J_b^T(\theta)\Bigg[P(\theta)\left(K_p X_e + K_i\int_0^t X_e(t)dt + K_d V_e\right) \\
&\quad + (I - P(\theta))\left(F_d + K_{fp}F_e + K_{fi}\int_0^t F_e(t)dt\right) \\
&\quad + \eta(\theta, V_b)\Bigg]
\end{split}
\end{equation}

其中：
\begin{itemize}
    \item 第一项：运动控制（投影到运动子空间）
    \item 第二项：力控制（投影到力子空间）
    \item 第三项：动力学补偿
\end{itemize}

\section{代码结构}

\subsection{类定义：OSICViewer}

\texttt{OSICViewer} 类实现了完整的混合力位控制系统。

\subsubsection{初始化方法 \texttt{\_\_init\_\_}}

初始化过程包括：

\begin{enumerate}
    \item \textbf{加载 MuJoCo 模型}：
    \begin{lstlisting}[firstnumber=15]
self.model = mujoco.MjModel.from_xml_path("surface_force_control.xml")
self.data = mujoco.MjData(self.model)
    \end{lstlisting}
    
    \item \textbf{设置初始关节配置}：
    \begin{lstlisting}[firstnumber=22]
qpos0 = np.array([0, -0.785, 0, -2.356, 0, 1.571, 0.785])
    \end{lstlisting}
    
    \item \textbf{初始化动力学计算器}：
    \begin{lstlisting}[firstnumber=32]
self.dynamics_calc = DynamicsCalculator(...)
    \end{lstlisting}
    用于计算 $\Lambda(\theta)$ 和 $\eta(\theta, V)$。
    
    \item \textbf{设置控制参数}：
    \begin{itemize}
        \item 运动控制增益：$K_p$, $K_i$, $K_d$
        \item 力控制增益：$K_{fp}$, $K_{fi}$
        \item 目标力：$F_{\text{desired}} = -10.0$ N
    \end{itemize}
\end{enumerate}

\subsection{关键方法}

\subsubsection{雅可比矩阵计算}

\texttt{get\_jacobian\_6x7()} 方法计算 6DOF 雅可比矩阵：

\begin{lstlisting}[firstnumber=71]
def get_jacobian_6x7(self):
    """获取6DOF雅可比矩阵（位置+姿态）"""
    jacp = np.zeros((3, self.model.nv))
    jacr = np.zeros((3, self.model.nv))
    mujoco.mj_jacBody(self.model, self.data, jacp, jacr, hand_body_id)
    # 提取关节部分...
    return J  # 6x7 矩阵
\end{lstlisting}

雅可比矩阵将关节速度映射到任务空间速度：
\begin{equation}
V = J(\theta) \dot{\theta}
\end{equation}

\subsubsection{接触力检测}

\texttt{get\_contact\_force()} 方法检测接触状态和法向力：

\begin{lstlisting}[firstnumber=97]
def get_contact_force(self):
    # 遍历所有接触点
    for i in range(self.data.ncon):
        # 累加法向力分量
        force_z += f[2]
    # 滞后机制避免抖动
    if abs(force_z) > 1.0:
        self.is_contact_stable = True
    elif abs(force_z) < 0.05:
        self.is_contact_stable = False
    return self.is_contact_stable, force_z
\end{lstlisting}

\subsubsection{约束矩阵计算}

\texttt{compute\_constraint\_matrix()} 实现公式 11.57：

\begin{lstlisting}[firstnumber=126]
def compute_constraint_matrix(self):
    """计算约束矩阵 A(θ) - 公式11.57"""
    A = np.zeros((1, 6))
    A[0, 2] = 1.0  # 约束Z方向平移（法向）
    return A
\end{lstlisting}

对于表面接触，约束矩阵为：
\begin{equation}
A = \begin{bmatrix} 0 & 0 & 1 & 0 & 0 & 0 \end{bmatrix}
\end{equation}

表示约束法向（Z方向）运动。

\subsubsection{投影矩阵计算}

\texttt{compute\_projection\_matrix()} 实现公式 11.63：

\begin{lstlisting}[firstnumber=137]
def compute_projection_matrix(self, Lambda, A):
    """计算投影矩阵 P - 公式11.63"""
    Lambda_inv = np.linalg.inv(Lambda)
    A_Lambda_inv_AT = A @ Lambda_inv @ A.T
    A_Lambda_inv_AT_inv = np.linalg.inv(A_Lambda_inv_AT)
    P = np.eye(6) - A.T @ A_Lambda_inv_AT_inv @ A @ Lambda_inv
    return P
\end{lstlisting}

计算步骤：
\begin{enumerate}
    \item 计算 $\Lambda^{-1}$
    \item 计算 $(A\Lambda^{-1}A^T)^{-1}$
    \item 计算投影矩阵 $P = I - A^T(A\Lambda^{-1}A^T)^{-1}A\Lambda^{-1}$
\end{enumerate}

\subsection{核心控制方法}

\subsubsection{控制步骤 \texttt{control\_step}}

\texttt{control\_step()} 方法实现完整的混合控制算法，流程如下：

\paragraph{步骤 1：状态获取}

\begin{lstlisting}[firstnumber=164]
# 获取当前状态
pos_curr = np.array(self.data.body("panda_hand").xpos)
q = ...  # 关节角度
qdot = ...  # 关节角速度
J = self.get_jacobian_6x7()
V = J @ qdot  # 任务空间速度
\end{lstlisting}

\paragraph{步骤 2：动力学量计算}

\begin{lstlisting}[firstnumber=250]
# 计算任务空间质量矩阵 Λ(θ)
Lambda = self.dynamics_calc.compute_task_space_mass_matrix(
    q, task_space_dim=6, use_pseudoinverse=True, damping=1e-6
)

# 计算任务空间科里奥利项 η(θ, V)
eta = self.dynamics_calc.compute_task_space_coriolis(
    q, V, task_space_dim=6, use_pseudoinverse=True, damping=1e-6
)
\end{lstlisting}

\paragraph{步骤 3：约束和投影矩阵}

\begin{lstlisting}[firstnumber=262]
if is_contact:
    A = self.compute_constraint_matrix()  # 公式11.57
    P = self.compute_projection_matrix(Lambda, A)  # 公式11.63
else:
    P = np.eye(6)  # 无约束
\end{lstlisting}

\paragraph{步骤 4：混合控制计算}

\textbf{运动控制部分}（投影到运动子空间）：

\begin{lstlisting}[firstnumber=273]
# 位置和速度误差
X_e = pos_ref - pos_curr
V_e = vel_ref - V[:3]

# 更新积分项
self.X_e_integral += X_e * dt

# 运动控制（PID）
F_motion = P[:3, :3] @ (
    self.K_p @ X_e + 
    self.K_i @ self.X_e_integral + 
    self.K_d @ V_e
)
\end{lstlisting}

数学表达式：
\begin{equation}
F_{\text{motion}} = P_{[:3,:3]} \left(K_p X_e + K_i \int X_e dt + K_d V_e\right)
\end{equation}

\textbf{力控制部分}（投影到力子空间）：

\begin{lstlisting}[firstnumber=290]
if is_contact:
    # 力误差
    F_e = self.F_desired - F_curr
    self.F_e_integral += F_e * dt
    
    # 力控制wrench
    F_d = np.zeros(6)
    F_d[2] = self.F_desired + self.K_fp * F_e + self.K_fi * self.F_e_integral
    
    # 投影到力子空间
    F_force = (np.eye(6) - P) @ F_d
\end{lstlisting}

数学表达式：
\begin{equation}
F_{\text{force}} = (I - P) \left(F_d + K_{fp} F_e + K_{fi} \int F_e dt\right)
\end{equation}

\textbf{组合控制 wrench}：

\begin{lstlisting}[firstnumber=305]
F_cmd = np.zeros(6)
F_cmd[:3] = F_motion  # 运动控制
F_cmd += F_force      # 力控制
F_cmd += eta          # 动力学补偿
\end{lstlisting}

完整表达式：
\begin{equation}
F_{\text{cmd}} = F_{\text{motion}} + F_{\text{force}} + \eta(\theta, V)
\end{equation}

\paragraph{步骤 5：转换为关节力矩}

\begin{lstlisting}[firstnumber=311]
# τ = J^T F_cmd
tau = J.T @ F_cmd

# 添加重力补偿
tau += self.data.qfrc_bias

# 力矩限制
tau = np.clip(tau, -tau_max, tau_max)
\end{lstlisting}

最终控制律：
\begin{equation}
\tau = J^T(\theta) F_{\text{cmd}} + g(\theta)
\end{equation}

\section{参考轨迹生成}

\subsection{阶段识别}

控制系统分为两个主要阶段：

\begin{enumerate}
    \item \textbf{Phase 0}：接近阶段（无接触）
    \begin{itemize}
        \item 快速下降到接近表面
        \item 使用位置控制
        \item $z_{\text{des}} = 0.4 - \min(t/3.0, 1.0) \times 0.25$
    \end{itemize}
    
    \item \textbf{Phase 1}：接触阶段（有接触）
    \begin{itemize}
        \item 激活混合力位控制
        \item XY 方向：位置控制（切向运动）
        \item Z 方向：力控制（法向力）
    \end{itemize}
\end{enumerate}

\subsection{切向运动轨迹}

接触后，生成切向擦拭运动：

\subsubsection{X 轴前后擦拭（$0 \leq t_{\text{wipe}} < 15.0$ s）}

\begin{align}
\tau &= t_{\text{wipe}} \bmod 1.0 \\
p_{x,\text{ref}} &= \begin{cases}
0.5 + 0.15 \sin(\pi \tau / 0.5) & \text{if } \tau < 0.5 \\
0.5 + 0.15 \sin(\pi (1 - (\tau-0.5)/0.5)) & \text{if } \tau \geq 0.5
\end{cases}
\end{align}

\subsubsection{Y 轴左右擦拭（$t_{\text{wipe}} \geq 15.0$ s）}

\begin{align}
\tau &= (t_{\text{wipe}} - 15.0) \bmod 1.0 \\
p_{y,\text{ref}} &= \begin{cases}
-0.1 \sin(\pi \tau / 0.5) & \text{if } \tau < 0.5 \\
-0.1 \sin(\pi (1 - (\tau-0.5)/0.5)) & \text{if } \tau \geq 0.5
\end{cases}
\end{align}

\section{控制参数}

\subsection{运动控制增益}

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{参数} & \textbf{数值} & \textbf{说明} \\
\hline
$K_p$ (X, Y) & 800.0 & X/Y 位置比例增益 \\
$K_p$ (Z) & 300.0 & Z 位置比例增益 \\
$K_i$ (X, Y) & 10.0 & X/Y 积分增益 \\
$K_i$ (Z) & 5.0 & Z 积分增益 \\
$K_d$ (X, Y) & 50.0 & X/Y 微分增益 \\
$K_d$ (Z) & 20.0 & Z 微分增益 \\
\hline
\end{tabular}
\caption{运动控制增益参数}
\end{table}

\subsection{力控制增益}

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{参数} & \textbf{数值} & \textbf{说明} \\
\hline
$K_{fp}$ & 0.5 & 力比例增益 \\
$K_{fi}$ & 0.1 & 力积分增益 \\
$F_{\text{desired}}$ & -10.0 N & 目标法向力 \\
\hline
\end{tabular}
\caption{力控制增益参数}
\end{table}

\section{实现细节}

\subsection{数值稳定性}

\subsubsection{奇异点处理}

在计算投影矩阵时，使用条件数检测和处理奇异情况：

\begin{lstlisting}[firstnumber=146]
if np.linalg.cond(A_Lambda_inv_AT) > 1e10:
    A_Lambda_inv_AT_inv = np.linalg.pinv(A_Lambda_inv_AT)
else:
    A_Lambda_inv_AT_inv = np.linalg.inv(A_Lambda_inv_AT)
\end{lstlisting}

\subsubsection{积分饱和限制}

防止积分项饱和：

\begin{lstlisting}[firstnumber=279]
self.X_e_integral = np.clip(self.X_e_integral, -0.1, 0.1)
self.F_e_integral = np.clip(self.F_e_integral, -50.0, 50.0)
\end{lstlisting}

\subsection{接触检测滞后机制}

使用滞后机制避免接触状态抖动：

\begin{lstlisting}[firstnumber=118]
if abs(force_z) > 1.0:  # 有显著力
    self.is_contact_stable = True
elif abs(force_z) < 0.05:  # 力完全消失
    self.is_contact_stable = False
# 其他情况保持现有状态
\end{lstlisting}

\section{仿真流程}

\texttt{run\_with\_viewer()} 方法实现主仿真循环：

\begin{lstlisting}[firstnumber=359]
while viewer.is_running() and t < duration:
    # 1. 执行控制
    self.control_step(t)
    
    # 2. 物理仿真步进
    mujoco.mj_step(self.model, self.data)
    
    # 3. 更新viewer
    viewer.sync()
    
    # 4. 进度报告
    if t - last_print >= 5.0:
        print(...)
    
    t += dt
\end{lstlisting}

每个仿真步骤：
\begin{enumerate}
    \item 计算控制力矩（混合力位控制）
    \item 推进物理仿真（MuJoCo）
    \item 更新可视化显示
    \item 输出状态信息
\end{enumerate}

\section{总结}

本文档详细解释了基于约束的混合力位控制实现。关键点：

\begin{enumerate}
    \item \textbf{约束建模}：使用 Pfaffian 约束描述表面接触
    \item \textbf{投影分离}：通过投影矩阵分离运动和力控制
    \item \textbf{动力学补偿}：使用任务空间质量矩阵和科里奥利项
    \item \textbf{混合控制}：同时实现位置控制和力控制
    \item \textbf{数值稳定}：处理奇异点和积分饱和
\end{enumerate}

该实现遵循理论框架（公式 11.57--11.64），为机器人表面操作提供了稳定可靠的控制方案。

\end{document}

